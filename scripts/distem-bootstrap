#!/usr/bin/ruby
#
# distem-bootstrap is a script to configure a set of nodes as distem nodes
# after they have been successfully deployed. Example usage:
#   oarsub -t deploy -l nodes=10,walltime=1 \
#      'katapult3 -e squeeze-x64-min -c --sleep -- distem-bootstrap'
#   see distem-bootstrap --help for more info.
#
####
# distem-bootstrap is Copyright (C) 2011 Luc Sarzyniec <luc.sarzyniec@inria.fr>
# Secondary contact: Lucas Nussbaum <lucas.nussbaum@loria.fr>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
######
require 'rubygems'
require 'net/ssh/multi'
require 'socket'
require 'etc'
require 'yaml'
require 'optparse'


def g5k?
  `hostname --fqdn`.chomp =~ /grid5000\.fr$/
end

PKG_NAME          = 'distem'
DEB_REPOSITORY    = 'http://distem.gforge.inria.fr/deb'
HTTP_PROXY        = 'http://proxy:3128/'
SSH_KEYS          = ["#{ENV['HOME']}/.ssh/id_dsa", "#{ENV['HOME']}/.ssh/id_rsa"]
PATH_DISTEMD_LOGS = '/var/log/distem'
TMP_DIR           = '/tmp/distem'
VAR_DISTEM_NODES  = 'DISTEM_NODES'
VAR_DISTEM_COORD  = 'DISTEM_COORDINATOR'
STATS_PORT        = 12345
if g5k?
  GIT_REPOSITORY  = "git://beaujolais.nancy.grid5000.fr/distem/distem.git"
  GERRIT_REPOSITORY = "http://gerrit.nancy.grid5000.fr:8081/p/distem"
  STATS_SERV      = "carol.nancy.grid5000.fr"
else
  GIT_REPOSITORY  = "git://scm.gforge.inria.fr/distem/distem.git"
  GERRIT_REPOSITORY = "http://localhost:8081/p/distem" # assuming we have a tunnel...
  STATS_SERV      = ""
end

ULIMIT_OPEN_FILES = 65535 # to be removed


pkg_utils=[
  'htop'
]

pkg_tmp_dependencies=[
  'cpufrequtils',
  'ethtool',
  'lsof' # needed until hack to wait for distemd startup is removed
]

pkg_build=[
  'git',
  'rake'
]

pkg_build_gem=[
  #'rake-compiler'
]

options = {}
@options = options

MSG_ERROR=0
MSG_WARNING=1
MSG_INFO=2

def msg(str, type=nil, quit=false)
  case type
  when MSG_ERROR
    puts("### Error: #{str} ###")
  when MSG_WARNING
    puts("### Warning: #{str} ###")
  when MSG_INFO
    puts("[#{(Time.now - $startt).to_i}] #{str}")
  else
    puts str
  end
  exit 1 if quit
end

def open_channel(session, group = nil)
  if group.is_a?(Symbol)
    session.with(group).open_channel do |channel|
      yield(channel)
    end
  elsif group.is_a?(Array)
    session.on(*group).open_channel do |channel|
      yield(channel)
    end
  elsif group.is_a?(Net::SSH::Multi::Server)
    session.on(group).open_channel do |channel|
      yield(channel)
    end
  else
    session.open_channel do |channel|
      yield(channel)
    end
  end
end

def exec(session, cmd, group = nil, critical = true, showerr = true, showout = false)
  outs = {}
  errs = {}

  channel = open_channel(session,group) do |chtmp|
    chtmp.exec(cmd) do |ch, success|
      unless success
        msg("unable to execute '#{cmd}' on #{ch.connection.host}",MSG_ERROR)
      end
      msg("Executing '#{cmd}' on #{ch.connection.host}]",MSG_INFO) \
        if @options[:debug]
    end
  end

  channel.on_data do |chtmp,data|
    outs[chtmp.connection.host] = [] unless outs[chtmp.connection.host]
    outs[chtmp.connection.host] << data.strip
    msg("[#{chtmp.connection.host}] #{data.strip}") \
      if @options[:debug] or showout
  end

  channel.on_extended_data do |chtmp,type,data|
    errs[chtmp.connection.host] = [] unless errs[chtmp.connection.host]
    errs[chtmp.connection.host] << data.strip
    msg("[#{chtmp.connection.host} E] #{data.strip}") \
      if @options[:debug] or showout
  end

  channel.on_request("exit-status") do |chtmp, data|
    status = data.read_long
    if status != 0
      if showerr or critical
        msg("exec of '#{cmd}' on #{chtmp.connection.host} failed " \
          "with return status #{status.to_s}",MSG_ERROR)
        msg("---stdout dump---")
        outs[chtmp.connection.host].each { |out| msg(out) } if \
          outs[chtmp.connection.host]
        msg("---stderr dump---")
        errs[chtmp.connection.host].each { |err| msg(err) } if \
          errs[chtmp.connection.host]
        msg("---\n")
      end
      exit 1 if critical
    end
  end

  channel.wait

  return outs
end


$startt = Time::now

options[:init_pnodes] = true
options[:coordinator] = nil
options[:node_list]   = nil
options[:debpackages] = []
options[:gempackages] = []
options[:git]         = nil
options[:gerrit]      = nil
options[:ssh_key]     = nil
options[:debug]       = false
options[:version]     = nil
options[:debug_distem] = false
options[:stats]       = true
options[:git_url]     = GIT_REPOSITORY

args = ARGV.dup

optparse = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] [<script_to_execute>]"
  opts.separator ""
  opts.separator "distem-bootstrap automatically sets up a distem environment."
  opts.separator "When run without options, it will create a distem environment with the latest"
  opts.separator "released version of distem, using the nodes from $OAR_NODEFILE or $GOOD_NODES."
  opts.separator ""
  opts.separator "Options:"

  opts.on( '-f', '--node-list <nodelist_file>', 'File containing the list of nodes to install. If not specified, will use $GOOD_NODES or $OAR_NODEFILE') do |n|
    options[:node_list] = n
  end
  opts.on( '-c', '--coordinator <coordinator_address>', 'Address of the coordinator (default: first node)' ) do |c|
    options[:coordinator] = c || nil
  end
  opts.on( '-x', '--no-init-pnodes', 'Do not initialize all pnodes' ) do |c|
    options[:init_pnodes] = false
  end
  opts.on( '-d', '--debug', 'Debug mode (display commands executed on nodes)' ) do
    options[:debug] = true
  end
  opts.on( '-D', '--distem-debug', 'Show distem output when executing distem commands (script, node init)' ) do
    options[:debug_distem] = true
  end
  opts.on( '-k', '--ssh-key [<ssh_key_file>]', 'Path of the ssh private key to use' ) do |k|
    options[:ssh_key] = k
  end
  opts.on( '-p', '--debpackages <package1>,<package2>,<...>', Array, 'Additional debian packages to install on coordinator' ) do |p|
    options[:debpackages] = p
  end
  opts.on( '-r', '--gempackages <package1>,<package2>,<...>', Array, 'Additional gem packages to install on coordinator' ) do |p|
    options[:gempackages] = p
  end
  opts.on( '-v', '--version <distem_version>', 'Version of distem to install (default: latest)' ) do |v|
    options[:version] = v
  end
  opts.on( '-g', '--git [<git_hash|git_tag>]', "Install a git snapshot of distem (default: master). Additional packages are installed on the coordinator to rebuild the Debian package" ) do |n|
    options[:git] = n || :git_last
  end
  opts.on( '-U', '--git-url <git-repository>', "Overwrite the default distem git repository" ) do |repo|
    options[:git_url] = repo
  end
  opts.on( '-G', '--gerrit <gerrit_ref>', "Checkout a gerrit ref (e.g refs/changes/94/94/1) and rebuild a Debian package" ) do |n|
    options[:gerrit] = n
  end
  opts.on( '-S', '--stealth-mode', 'Do not report usage statistics (Grid\'5000 only)' ) do |c|
    options[:stats] = false
  end
  opts.on( '-h', '--help', 'Display this screen' ) do
    puts opts
    exit
  end
  opts.separator ""
  opts.separator "When executing a script, the file containing the list of nodes is available in the #{VAR_DISTEM_NODES}"
  opts.separator "environment variable, while the address of the coordinator is in #{VAR_DISTEM_COORD}."
  opts.separator ""
  opts.separator "Examples:"
  opts.separator "# reserve and deploy nodes using katapult3, then install distem"
  opts.separator "oarsub -t deploy -l nodes=10,walltime=1 \\"
  opts.separator " 'katapult3 -e squeeze-x64-min -c --sleep -- distem-bootstrap'"
  opts.separator "# run script.rb against the latest git snapshot of distem"
  opts.separator "distem-bootstrap --no-init-pnodes --git -- script.rb"
  opts.separator "# setup distem, installing additional packages"
  opts.separator "distem-bootstrap -p htop -r restfully -f nodes"

end

begin
  optparse.parse!
rescue OptionParser::InvalidOption => e
  msg(e.to_s,MSG_ERROR,true)
end

nodelist = []

if options[:node_list]
  nodelist_file = options[:node_list]
elsif (ENV['GOOD_NODES'])
  nodelist_file = ENV['GOOD_NODES']
elsif (ENV['OAR_NODEFILE'])
  nodelist_file = ENV['OAR_NODEFILE']
else
  msg("nodelist parameter not set",MSG_ERROR,true)
end

begin
  nodelist = IO::readlines(nodelist_file).map { |l| l.strip }.uniq
rescue Errno::ENOENT
  puts "File '#{nodelist_file}' not found"
  exit 1
end

if nodelist.empty?
  msg("nodelist parameter empty",MSG_ERROR,true)
end
allnodes = nodelist.dup

if options[:coordinator]
  coordinator = options[:coordinator]
else
  coordinator = nodelist[0]
end

if nodelist.include?(coordinator)
  nodelist.delete(coordinator)
else
  tmp = nodelist.select { |node| node =~ /^#{coordinator}/ }
    if tmp.empty?
    msg("Coordinator not present in <nodes_file>",MSG_WARNING)
  else
    msg("Coordinator '#{coordinator}' assumed to be '#{tmp[0]}' (which is present in <nodes_file>)",MSG_WARNING)
    coordinator = tmp[0]
  end
end

if g5k? and `g5k-subnets`.strip.empty?
  msg('you did not make a subnet reservation (See g5k-subnets)',MSG_WARNING)
end

if options[:ssh_key]
  if File.exists?(options[:ssh_key])
    sshkeyfile = options[:ssh_key]
  else
    msg("ssh key #{options[:ssh_key]} not found",MSG_ERR,true)
  end
else
  sshkeyfiles = SSH_KEYS.select { |keypath| File.exists?(keypath) }
  if sshkeyfiles.empty?
    msg("no ssh private key file found (specify one with -k)",MSG_ERROR,true)
  else
    sshkeyfile = sshkeyfiles[0]
  end
end

msg("Copying ssh private key file to the coordinator machine (#{coordinator})",
  MSG_INFO)
`scp #{sshkeyfile} root@#{coordinator}:/root/.ssh/`

msg("Establishing SSH connections to all nodes", MSG_INFO)
Net::SSH::Multi.start do |session|
  nodeobjlist = {}
  begin
    session.group :coord do
      nodeobjlist[coordinator] = session.use("root@#{coordinator}")
    end
    #test the connection
    exec(session,"hostname",:coord)
  rescue SocketError
    msg("can't connect to #{coordinator}",MSG_ERROR,true)
  end
  session.group :nodes do
    nodelist.each do |node|
      begin
        nodeobjlist[node] = session.use("root@#{node}")
        #test the connection
        exec(session,"hostname",nodeobjlist[node])
      rescue SocketError
        msg("can't connect to #{node}",MSG_ERROR,true)
      end
    end
  end

  # Check nfs paths
  tmp = exec(session,"ls -a #{File.join('/','home',ENV['USER'])}",nil,false,false)
  nopath = allnodes - tmp.keys
  nopath.each do |node|
    msg("NFS do not seems to be mounted on #{node} (check that you have deployed with NFS env)",MSG_WARNING)
  end

  #setting up ulimit-open_files, to be removed
  rule="root hard nofile"
  rulenodes = exec(session,"grep '#{rule}' /etc/security/limits.conf; true")
  rulemissing=allnodes - rulenodes.keys
  rulemissing.collect!{ |node| nodeobjlist[node] }
  rulemissing.each { |node| exec(session,"echo '#{rule} #{ULIMIT_OPEN_FILES}'" \
    ">> /etc/security/limits.conf",node) } 
  rule="root soft nofile"
  rulenodes = exec(session,"grep '#{rule}' /etc/security/limits.conf; true")
  rulemissing=allnodes - rulenodes.keys
  rulemissing.collect!{ |node| nodeobjlist[node] }
  rulemissing.each { |node| exec(session,"echo '#{rule} #{ULIMIT_OPEN_FILES}'" \
    ">> /etc/security/limits.conf",node) } 

  havesources = exec(session,"grep '#{DEB_REPOSITORY}' /etc/apt/sources.list",
    nil, false, false).keys
  needsources = (nodelist + [coordinator]) - havesources

  unless needsources.empty?
    needsources.collect!{ |node| nodeobjlist[node] }
    exec(session,"echo 'deb #{DEB_REPOSITORY} ./\ndeb-src #{DEB_REPOSITORY} ./' " \
      ">> /etc/apt/sources.list", needsources)
    session.loop
  end

  msg("Updating debian packages list",MSG_INFO)
  exec(session,'apt-get update -q')

  if options[:git] or options[:gerrit]
    msg("Installing debian build packages on #{coordinator}",MSG_INFO)
    exec(session,"apt-get build-dep -y --force-yes distem",:coord)
    exec(session,"apt-get install -q -y --force-yes #{pkg_build * ' '}",
      :coord) unless pkg_build.empty?
    unless pkg_build_gem.empty?
      msg("Installing gems build packages on #{coordinator}",MSG_INFO)
      exec(session,"export http_proxy=#{HTTP_PROXY};" \
        "gem install #{pkg_build_gem * ' '}",:coord)
    end
    gitdir = "#{TMP_DIR}/git"
    exec(session,"mkdir -p #{TMP_DIR}")
    exec(session,"rm -Rf #{gitdir}",:coord, false, false)
    if options[:git]
      msg("Retrieving '#{options[:git_url]}' repository on #{coordinator}",MSG_INFO)
      exec(session,"git clone #{options[:git_url]} #{gitdir}",:coord)
      unless options[:git] == :git_last
        msg("Setting up git repository ref:#{options[:git]} on #{coordinator}",
            MSG_INFO)
            exec(session,"git --git-dir=#{gitdir}/.git reset --hard #{options[:git]}",
                 :coord)
      end
    else # gerrit
      msg("Setting up git repository from gerrit ref:#{options[:gerrit]} on #{coordinator}",
            MSG_INFO)
      exec(session,"git clone #{GERRIT_REPOSITORY} #{gitdir}",:coord)
      exec(session,"cd #{gitdir} && git fetch #{GERRIT_REPOSITORY} #{options[:gerrit]} && git checkout FETCH_HEAD", :coord)
    end
    msg("Building debian package of distem on #{coordinator}",MSG_INFO)
    exec(session,"rm -f #{TMP_DIR}/*.deb #{TMP_DIR}/*.changes #{TMP_DIR}/*.dsc"\
      " #{TMP_DIR}/*.tar.gz",:coord)
    exec(session,"cd #{gitdir}; rake snapshot",:coord)

    debarchivefile = exec(session,"find #{TMP_DIR} -maxdepth 1 -name *.deb",
      :coord)[coordinator][0]
    msg("Copying generated debian package #{File.basename(debarchivefile)}",
      MSG_INFO)
    #exec(session,"cp #{debarchivefile} #{TMP_DIR}",:coord,true)
    nodelist.each {|node| exec(session,"scp -o StrictHostKeyChecking=no " \
      "#{debarchivefile} root@#{node}:#{TMP_DIR}",:coord)}
    msg("Installing generated debian package #{File.basename(debarchivefile)}",
      MSG_INFO)
    depends = exec(session,"dpkg -I #{debarchivefile} | grep 'Depends:'",
      :coord)[coordinator][0]
    depends = depends.split("|").last.gsub!(' ','')
    exec(session,"dpkg --ignore-depends #{depends} " \
      "-i #{TMP_DIR}/#{File.basename(debarchivefile)}")
    exec(session,"echo yes | apt-get install -q -y --force-yes -f")
    msg("Cleaning installation files on #{coordinator}",MSG_INFO)
    exec(session,"rm -Rf #{gitdir}",:coord)
    exec(session,"rm -f #{TMP_DIR}/*.deb #{TMP_DIR}/*.changes #{TMP_DIR}/*.dsc #{TMP_DIR}/*.tar.gz",:coord)
  else
    msg("Installing debian distem packages",MSG_INFO)
    distempkg = (options[:version]?"#{PKG_NAME}=#{options[:version]}":PKG_NAME)
    exec(session,"echo yes | apt-get install -q -y --force-yes " \
      "--allow-unauthenticated #{distempkg}")
  end

  msg("Installing debian misc packages",MSG_INFO)
  exec(session,"apt-get install -q -y --force-yes #{pkg_tmp_dependencies * ' '}") \
    unless pkg_tmp_dependencies.empty?
  exec(session,"apt-get install -q -y --force-yes #{pkg_utils * ' '}") \
    unless pkg_utils.empty?
  options[:debpackages].each do |debpkg|
    msg("Installing additional debian package '#{debpkg}'",MSG_INFO)
    exec(session,"apt-get install -q -y --force-yes #{debpkg}")
  end
  options[:gempackages].each do |gempkg|
    msg("Installing additional gem package '#{gempkg}'",MSG_INFO)
    exec(session,"export http_proxy=#{HTTP_PROXY}; gem install #{gempkg}",
      :coord)
  end

  session.loop

  if options[:init_pnodes] or ARGV[0]
    launched = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",nil,false,false)
    unless launched.empty?
      tokill = launched.keys
      tokill.collect!{ |node| nodeobjlist[node] }
      tokill.each { |node|
        msg("Killing previous run of distem on #{node}",MSG_INFO)
      }
      exec(session,"killall distemd",tokill,false,false)
      time_start = Time.now
      until !launched or launched.empty?
        exec(session,"killall -9 distemd",tokill,false,false) \
          if (Time.now - time_start) > 2
        launched = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",
          tokill,false,false)
        if launched and !launched.empty?
          tokill = launched.keys
          tokill.collect!{ |node| nodeobjlist[node] }
        end
      end
      session.loop
    end

    msg("Starting coordinator daemon on #{coordinator}",MSG_INFO)
    exec(session,"mkdir -p #{PATH_DISTEMD_LOGS}",:coord)
    exec(session,"distemd -d &>#{File.join(PATH_DISTEMD_LOGS,'distemd.log')} &",
      :coord)

    launched = []
    until launched and !launched.empty?
      launched = exec(session,"lsof -Pnl -i4 | grep '^distemd.*$'",:coord,false,
        false)[coordinator]
      sleep(0.1)
    end

    session.loop

    if options[:init_pnodes]
      msg("Initializing node #{coordinator}",MSG_INFO)
      exec(session,"distem -d #{coordinator} -i #{coordinator}",:coord,true,
        options[:debug_distem],options[:debug_distem])
      nodelist.each do |node|
        msg("Initializing node #{node}",MSG_INFO)
        exec(session,"distem -d #{coordinator} -i #{node}",:coord,true,
          options[:debug_distem],options[:debug_distem])
      end
    end

  end

  msg('Install done',MSG_INFO)

  if ARGV[0]
    begin
      File.open(ARGV[0], 'r') do |f|
        filename = exec(session,'tempfile',:coord)[coordinator][0]
        msg("Copying script file in '#{filename}' on #{coordinator}",MSG_INFO)
        `scp #{ARGV[0]} root@#{coordinator}:#{filename}`      
        exec(session,"chmod +x #{filename}",:coord)
        msg("Executing script file '#{filename}' on #{coordinator}",
          MSG_INFO)

        ARGV_dup = ARGV.dup
        ARGV_dup.shift
        script_args = (ARGV_dup.length > 0 ? ARGV_dup.join(" ") : "")
        exec(session,
          "export #{VAR_DISTEM_NODES}='#{(nodelist + [coordinator]) * "\n"}';" \
          "export #{VAR_DISTEM_COORD}='#{coordinator}';" \
          "#{filename} #{script_args}",:coord,true,true,true)
        exec(session,"rm #{filename}",:coord)
      end
      msg('Script execution done',MSG_INFO)
    rescue Errno::ENOENT
      msg("script file '#{ARGV[0]}' not found",MSG_ERROR,true)
    end
  end

  msg("Coordinator: #{coordinator}") if options[:init_pnodes] or ARGV[0]

  # Send stats record to stats server
  if g5k? and options[:stats]
    begin
      stats = {
        :time => Time.now.to_i,
        :site => Socket.gethostname,
        :user => ENV['USER'],
        :oar 	=> ENV['OAR_JOB_ID'].to_i,
        :nodes => allnodes,
        :params => args * ' ',
        :length => (Time.now - $startt).to_i
      }
      sock = TCPSocket.open(STATS_SERV, STATS_PORT)
      sock.send(stats.to_yaml,0)
      sock.close
    rescue SocketError, Errno::ECONNREFUSED, Errno::ECONNRESET, Errno::ETIMEDOUT, Errno::EHOSTUNREACH
    end
  end
end
